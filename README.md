# test-learning

## テストケース

### ToDoList コンポーネント

1. **基本的なレンダリング**
    - `ToDoList` コンポーネントが正しくレンダリングされること。
    - 初期状態では、ToDo項目が0個であること。

2. **ToDo項目の追加**
    - 入力フォームにテキストを入力して追加ボタンをクリックすると、ToDo項目が追加されること。
    - 追加されたToDo項目がリスト内に正しく表示されること。

3. **ToDo項目の削除**
    - 削除ボタンをクリックすると、対応するToDo項目がリストから削除されること。

### ToDoItem コンポーネント

1. **基本的なレンダリング**
    - `ToDoItem` コンポーネントが受け取ったプロップスに基づいて正しくレンダリングされること。
    - ToDoのテキストと削除ボタンが表示されること。

2. **削除ボタンの動作**
    - `ToDoItem` の削除ボタンをクリックすると、親コンポーネントからのコールバック関数が呼び出されること。

## 考え方

考え方の流れ

### 1. テストの目的を明確にする

テストを書く前に、何をテストするのか、そのテストの目的は何かを明確にする。例えば、`ToDoItem`の削除ボタンが正しく動作するか、というのが一つのテストの目的となる。

### 2. コンポーネントに`data-testid`を追加

テスト対象のコンポーネントや要素に一意の`data-testid`をつける。これにより、テスト時に特定の要素を簡単に選択できるようになります。壊れづらいテストにとって大切。

例:
- `ToDoList`の入力フォーム: `data-testid="todo-input"`
- `ToDoItem`のテキスト: `data-testid="todo-text"`
- `ToDoItem`の削除ボタン: `data-testid="todo-delete-button"`

### 3. Jestと関連ライブラリを用いて要素の選択

`@testing-library/react`などのライブラリを使用して、`data-testid`に基づいて要素を選択する。

例:
`const inputElement = screen.getByTestId('todo-input');`

### 4. 動作をシミュレーション

選択した要素に対してアクション（クリック、入力など）をシミュレートする。

例:
入力フォームにテキストを入力する場合: `fireEvent.change(inputElement, { target: { value: '新しいToDo' } });`

### 5. 検証

アクション後の状態や表示が期待通りであるかを検証する。

例:
ToDo項目が正しく追加されたかを検証: `expect(screen.getByTestId('todo-text')).toHaveTextContent('新しいToDo');`

### 6. エッジケースの考慮

正常系だけでなく、エッジケースや異常系も考慮し、それに対するテストケースを追加する。

例:
入力フォームが空の状態で追加ボタンをクリックしたとき、ToDo項目は追加されない、といったケース。
